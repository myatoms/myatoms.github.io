<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hydrogen - My Atoms</title>

  <!-- NOTE: removed Google Fonts link (some networks block fonts.googleapis.com causing MIME errors).
       If you self-host the Alsina font later, add an @font-face block here. -->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family: Arial, sans-serif; }
    #viewer { position:absolute; top:0; left:0; width:100%; height:calc(100% - 120px); background:black; }
    #info {
      position:absolute; left:0; bottom:0; width:100%; height:120px;
      background:#111; color:#fff; padding:12px; box-sizing:border-box;
      display:flex; align-items:center; gap:14px; font-size:16px;
    }
    .toggle { display:flex; align-items:center; gap:8px; }
    input[type="checkbox"]{ transform:scale(1.05); }
    #error {
      position: absolute; top:12px; left:12px; z-index:9999;
      background: rgba(255,0,0,0.08); color:#ffdddd; padding:8px 10px; border-radius:6px; display:none;
    }
  </style>
</head>
<body>
  <div id="viewer" aria-hidden="false"></div>

  <div id="info">
    <label class="toggle"><input type="checkbox" id="showLabels" checked> Show Labels</label>
    <p style="margin:0;"><strong>Hydrogen (H)</strong> â€“ description goes here.</p>
  </div>

  <div id="error" role="alert"></div>

  <script>
    // Small helper to show error on-page + console
    function showError(text) {
      console.error(text);
      const el = document.getElementById('error');
      el.textContent = text;
      el.style.display = 'block';
    }

    // Try to load a script and resolve when loaded, reject after timeout/error
    function loadScript(src, timeout = 7000) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        let done = false;
        const timer = setTimeout(() => {
          if (!done) {
            done = true;
            s.onerror = s.onload = null;
            reject(new Error('Timeout loading ' + src));
          }
        }, timeout);
        s.onload = () => {
          if (done) return;
          done = true;
          clearTimeout(timer);
          resolve();
        };
        s.onerror = (e) => {
          if (done) return;
          done = true;
          clearTimeout(timer);
          reject(new Error('Failed to load ' + src));
        };
        document.head.appendChild(s);
      });
    }

    // Try primary then fallback CDNs for 3Dmol
    async function ensure3Dmol() {
      const primary = 'https://3dmol.csb.pitt.edu/build/3Dmol-min.js';
      const fallback = 'https://3Dmol.org/build/3Dmol-min.js';
      try {
        await loadScript(primary, 7000);
        if (!window.$3Dmol) throw new Error('3Dmol loaded but $3Dmol missing (primary).');
        return;
      } catch (e1) {
        console.warn('Primary 3Dmol failed:', e1.message);
        try {
          await loadScript(fallback, 7000);
          if (!window.$3Dmol) throw new Error('3Dmol loaded but $3Dmol missing (fallback).');
          return;
        } catch (e2) {
          throw new Error('Failed to load 3Dmol library from both CDNs.');
        }
      }
    }

    // Main init
    (async function init() {
      try {
        await ensure3Dmol();
      } catch (err) {
        showError('Could not load 3D viewer library: ' + err.message);
        return;
      }

      try {
        // Create viewer
        const viewer = $3Dmol.createViewer('viewer', { backgroundColor: 'black', antialias: true });

        // Parameters
        const ORBIT_RADIUS = 1.0;
        const PROTON_RADIUS = 0.30;
        const ELECTRON_RADIUS = 0.15;

        // Orbit points (static)
        function makeOrbit(radius, segments = 160) {
          const pts = [];
          for (let i = 0; i <= segments; i++) {
            const theta = (2 * Math.PI) * (i / segments);
            pts.push({ x: radius * Math.cos(theta), y: radius * Math.sin(theta), z: 0 });
          }
          return pts;
        }
        const orbitPts = makeOrbit(ORBIT_RADIUS, 160);

        // Animation control
        let running = true;
        let last = performance.now();
        const targetFPS = 60;
        const minDt = 1000 / targetFPS;
        const labelCheckbox = document.getElementById('showLabels');

        // Pause when page hidden
        document.addEventListener('visibilitychange', () => {
          running = !document.hidden;
          if (running) requestAnimationFrame(loop);
        });

        // Resize handling (best-effort)
        window.addEventListener('resize', () => { try { viewer.resize(); } catch(e) {} });

        // Draw one frame (time in ms)
        function draw(now) {
          const t = now / 1000;
          const rps = 0.85;
          const angle = t * 2 * Math.PI * rps;
          const zWobble = Math.sin(t * 2 * Math.PI * 0.55) * 0.18;

          const ex = ORBIT_RADIUS * Math.cos(angle);
          const ey = ORBIT_RADIUS * Math.sin(angle);
          const ez = zWobble;

          // Clear small scene (cheap)
          try { viewer.clear(); } catch (e) { try { viewer.removeAllModels && viewer.removeAllModels(); } catch (e2) {} }

          // Proton
          viewer.addSphere({ center: { x:0, y:0, z:0 }, radius: PROTON_RADIUS, color: 'red', opacity: 1.0 });

          // Electron
          viewer.addSphere({ center: { x: ex, y: ey, z: ez }, radius: ELECTRON_RADIUS, color: 'yellow', opacity: 1.0 });

          // Orbit curve
          viewer.addCurve({ points: orbitPts, color: 'white', linewidth: 1.2 });

          // Labels (toggleable)
          if (labelCheckbox.checked) {
            viewer.addLabel('Proton', { position: { x: 0, y: 0.55, z: 0 }, backgroundColor: 'red', fontColor: 'black', fontSize: 12 });
            viewer.addLabel('Electron', { position: { x: ex + 0.06, y: ey + 0.06, z: ez + 0.06 }, backgroundColor: 'yellow', fontColor: 'black', fontSize: 12 });
          }

          // slight auto-tilt for depth (try/catch)
          try {
            const rotateSpeed = 0.12;
            const rotX = Math.sin(t * rotateSpeed) * 0.14;
            const rotY = Math.cos(t * rotateSpeed) * 0.14;
            viewer.setView({ rotation: [rotX, rotY, 0] });
          } catch (e) {}

          viewer.zoomTo();
          viewer.render();
        }

        // RAF loop with simple FPS gating
        function loop(now) {
          if (!running) return;
          const dt = now - last;
          if (dt >= minDt) {
            last = now - (dt % minDt);
            draw(now);
          }
          requestAnimationFrame(loop);
        }

        // Start loop
        requestAnimationFrame(loop);

        // ensure immediate initial draw
        try { draw(performance.now()); } catch (e) {}

        // label toggles immediately (loop runs continuously)
        labelCheckbox.addEventListener('change', () => { /* no-op - loop will redraw */ });

      } catch (err) {
        showError('Error initializing viewer: ' + (err && err.message ? err.message : err));
      }
    })();
  </script>
</body>
</html>
