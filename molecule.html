<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Molecule Simulator - Formula Only</title>
  <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
  <style>
    :root {
      --panel-w:320px;
      --bg:#000000;
      --panel-bg:#08101a;
      --muted:#9dbadf;
      --accent:#12a4ff;
      --ui:#e6eef8;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;}
    #app{display:flex;height:100vh;}
    #controls{width:var(--panel-w);min-width:260px;padding:18px;box-sizing:border-box;background:var(--panel-bg);border-right:1px solid rgba(255,255,255,0.03);overflow:auto;}
    #viewer{flex:1;position:relative;}
    h1{margin:0 0 8px 0;font-size:18px;color:var(--accent);}
    label{display:block;margin-top:12px;font-size:13px;color:var(--muted);}
    input[type=text]{width:100%;padding:9px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#071023;color:var(--ui);box-sizing:border-box;margin-top:8px;}
    button{margin-top:12px;padding:9px 12px;border-radius:8px;border:0;cursor:pointer;background:var(--accent);color:#002234;font-weight:600;}
    .toggles{margin-top:12px;display:flex;flex-direction:column;gap:8px;}
    .toggle{display:flex;align-items:center;gap:8px;}
    .small{font-size:12px;color:var(--muted);}
    .footer{margin-top:14px;font-size:12px;color:var(--muted);}
    .note{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.3;}
    a{color:var(--accent);text-decoration:none;}
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <h1>Molecule Simulator - Formula Only</h1>

      <label>Enter chemical formula only</label>
      <input id="molInput" value="NH3" placeholder="Examples: H2O, NH3, CH4, CO2, C6H6, C2H5OH" />

      <div style="display:flex;gap:8px;">
        <button id="confirmBtn">Render</button>
        <button id="examplesBtn">Examples</button>
      </div>

      <div class="toggles">
        <div class="toggle"><input id="showLabels" type="checkbox" checked> <label for="showLabels" class="small">Show labels</label></div>
        <div class="toggle"><input id="showBonds" type="checkbox" checked> <label for="showBonds" class="small">Show bonds</label></div>
        <div class="toggle"><input id="showNuclei" type="checkbox" checked> <label for="showNuclei" class="small">Show nuclei (red transparent)</label></div>
        <div class="toggle"><input id="lowQuality" type="checkbox"> <label for="lowQuality" class="small">Low quality for performance</label></div>
      </div>

      <div class="note">
        This tool accepts chemical formulas only. It builds connectivity based on valence heuristics and covalent radii, then computes a stable 3D geometry via a careful relaxation step. The result is static and stable for viewing and export.
      </div>

      <div class="footer small">
        If you want extra molecules added to a built in precise database, tell me which ones and I will add them.
      </div>
    </div>

    <div id="viewer"></div>
  </div>

  <script>
  // Improved universal formula-only molecule visualizer with robust parsing and error handling

  const viewer = $3Dmol.createViewer('viewer',{backgroundColor:'black',antialias:true});
  viewer.setBackgroundColor(0x000000);

  // Element visual data
  const elementColors = {
    H:'#FFFFFF', C:'#909090', N:'#3050F8', O:'#FF0D0D', F:'#90E050', Cl:'#1FF01F', S:'#FFFF30', P:'#FFA500',
    Li:'#CC80FF', Na:'#AB5CF2', Mg:'#8AFF00', Br:'#A62929', I:'#940094'
  };
  const covalentRadii = { H:0.31, C:0.76, N:0.71, O:0.66, F:0.57, P:1.07, S:1.05, Cl:1.02, Br:1.2, I:1.39 };

  // Typical valences for bonding heuristics
  const valences = { H:1, He:0, Li:1, Be:2, B:3, C:4, N:3, O:2, F:1, Ne:0, Na:1, Mg:2, Al:3, Si:4, P:3, S:2, Cl:1, Br:1, I:1 };

  // Normalize and parse chemical formula like C6H6 or H2O or h2o or (CH3)2CH
  function parseFormula(input) {
    if(!input) return null;
    try {
      // remove whitespace
      let s = input.replace(/\s+/g,'');
      if(s.length === 0) return null;

      // handle lowercase input by normalizing element letters to correct case
      // also keep parentheses and digits intact
      // scan string and rebuild standardized token sequence of [Element][count]
      const tokens = [];
      // Expand simple parenthesis groups like (CH3)2
      function expandParens(str) {
        // iterative approach to handle nested parentheses reasonably
        while(true) {
          const m = str.match(/\(([A-Za-z0-9]+)\)(\d+)/);
          if(!m) break;
          const group = m[1], count = parseInt(m[2]||'1',10);
          let rep = '';
          for(let i=0;i<count;i++) rep += group;
          str = str.replace(m[0], rep);
        }
        return str;
      }

      s = expandParens(s);

      // Use regex to capture sequences of letters (1 or 2) optionally followed by digits
      // But first we need to group letters correctly: iterate characters and build element tokens
      const parts = [];
      for(let i=0;i<s.length;) {
        const ch = s[i];
        if(/[A-Za-z]/.test(ch)) {
          // look ahead for second letter if it's lowercase or a letter
          let el = ch;
          if(i+1 < s.length && /[a-z]/.test(s[i+1])) {
            el += s[i+1];
            i += 2;
          } else {
            i += 1;
          }
          // capture number after the element if present
          let num = '';
          while(i < s.length && /[0-9]/.test(s[i])) { num += s[i]; i++; }
          parts.push({el, count: num ? parseInt(num,10) : 1});
        } else {
          // unexpected char like digit without preceding element or parentheses (shouldn't happen) -> abort
          // allow digits only after an element; if we encounter digits here parsing failed
          return null;
        }
      }

      // Now build atom list with corrected capitalization
      const atomList = [];
      for(const p of parts){
        const rawEl = p.el;
        const el = (rawEl.length === 1) ? rawEl.toUpperCase() : (rawEl[0].toUpperCase() + rawEl[1].toLowerCase());
        const cnt = p.count || 1;
        if(!/^[A-Z][a-z]?$/.test(el)) return null;
        for(let k=0;k<cnt;k++) atomList.push(el);
      }

      if(atomList.length === 0) return null;
      return atomList;
    } catch(err) {
      console.error('parseFormula error', err);
      return null;
    }
  }

  // Build connectivity using greedy algorithm using covalent radii and valence limits
  function buildConnectivity(atoms) {
    const n = atoms.length;
    // initial coords for distance heuristics
    const coords = [];
    for(let i=0;i<n;i++){
      coords.push({x:Math.random()*0.8 - 0.4, y:Math.random()*0.8 - 0.4, z:Math.random()*0.8 - 0.4});
    }
    const candidates = [];
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const ri = covalentRadii[atoms[i]] || 0.9;
        const rj = covalentRadii[atoms[j]] || 0.9;
        const target = (ri + rj) * 0.95;
        candidates.push({i,j,target});
      }
    }
    // prefer forming bonds between lighter targets first
    candidates.sort((a,b) => a.target - b.target);

    const bonds = [];
    const remainingValence = atoms.map(el => valences[el] != null ? valences[el] : 1);

    for(const c of candidates){
      if(remainingValence[c.i] > 0 && remainingValence[c.j] > 0) {
        bonds.push({a:c.i, b:c.j, rest: c.target});
        remainingValence[c.i]--; remainingValence[c.j]--;
      }
    }

    // Ensure connectivity: connect components if disconnected
    const parent = Array.from({length:n}, (_,i)=>i);
    function find(x){ return parent[x]===x ? x : (parent[x]=find(parent[x])); }
    function unify(a,b){ const ra=find(a), rb=find(b); if(ra!==rb) parent[ra]=rb; }
    bonds.forEach(b => unify(b.a, b.b));
    const comps = new Map();
    for(let i=0;i<n;i++){ const r=find(i); if(!comps.has(r)) comps.set(r, []); comps.get(r).push(i); }
    if(comps.size > 1) {
      const reps = Array.from(comps.values()).map(c=>c[0]);
      for(let i=0;i<reps.length-1;i++){
        const a = reps[i], b = reps[i+1];
        const ri = covalentRadii[atoms[a]] || 0.9, rj = covalentRadii[atoms[b]] || 0.9;
        bonds.push({a, b, rest: (ri + rj) * 0.95});
        unify(a,b);
      }
    }

    return { bonds, coords };
  }

  // Place atoms initial positions using BFS placement from a root atom chosen by degree and radius
  function placeInitialGeometry(atoms, bonds) {
    const n = atoms.length;
    const positions = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
    const deg = Array.from({length:n}, ()=>0);
    bonds.forEach(b => { deg[b.a]++; deg[b.b]++; });

    let root = 0;
    let bestScore = -Infinity;
    for(let i=0;i<n;i++){
      const score = deg[i] * 2 + (covalentRadii[atoms[i]] || 0);
      if(score > bestScore){ bestScore = score; root = i; }
    }

    const adj = Array.from({length:n}, ()=>[]);
    bonds.forEach(b => { adj[b.a].push(b.b); adj[b.b].push(b.a); });

    const visited = new Array(n).fill(false);
    const queue = [root];
    visited[root] = true;
    positions[root] = {x:0,y:0,z:0};

    while(queue.length){
      const cur = queue.shift();
      const neighbors = adj[cur];
      for(let k=0;k<neighbors.length;k++){
        const nb = neighbors[k];
        if(visited[nb]) continue;
        const phi = (k+1) * 2.399963229728653;
        const radius = ((covalentRadii[atoms[cur]]||0.9) + (covalentRadii[atoms[nb]]||0.9));
        const r = radius * 0.95;
        const x = positions[cur].x + r * Math.cos(phi) * (1 + 0.12*(Math.random()-0.5));
        const y = positions[cur].y + r * Math.sin(phi) * (1 + 0.12*(Math.random()-0.5));
        const z = positions[cur].z + (0.18 * (k - neighbors.length/2)) * (1 + 0.15*(Math.random()-0.5));
        positions[nb] = {x,y,z};
        visited[nb] = true;
        queue.push(nb);
      }
    }

    for(let i=0;i<n;i++){
      if(!visited[i]) positions[i] = {x:(Math.random()-0.5)*1.2, y:(Math.random()-0.5)*1.2, z:(Math.random()-0.5)*1.2};
    }

    return positions;
  }

  // Relaxation: strong bond springs, short-range repulsion, heavy damping until converged
  function relaxGeometry(atomsList, bonds, positions) {
    const n = atomsList.length;
    const maxIter = 2500;
    const dt = 0.02;
    const kBond = 140.0;
    const nonbondEps = 0.06;
    const damping = 0.32;
    const masses = atomsList.map(el => (covalentRadii[el]||0.9) * 10 + 1);
    const vel = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
    const restLen = bonds.map(b => b.rest || ((covalentRadii[atomsList[b.a]]||0.9) + (covalentRadii[atomsList[b.b]]||0.9)) * 0.95);
    const pos = positions.map(p => ({x:p.x, y:p.y, z:p.z}));

    for(let iter=0; iter<maxIter; iter++){
      const forces = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
      // bonds
      for(let bi=0; bi<bonds.length; bi++){
        const b = bonds[bi];
        const a = b.a, c = b.b;
        const rvec = { x: pos[c].x - pos[a].x, y: pos[c].y - pos[a].y, z: pos[c].z - pos[a].z };
        const dist = Math.hypot(rvec.x, rvec.y, rvec.z) + 1e-9;
        const dir = { x: rvec.x / dist, y: rvec.y / dist, z: rvec.z / dist };
        const diff = dist - restLen[bi];
        const fmag = -kBond * diff;
        const f = { x: dir.x * fmag, y: dir.y * fmag, z: dir.z * fmag };
        forces[a].x += f.x; forces[a].y += f.y; forces[a].z += f.z;
        forces[c].x -= f.x; forces[c].y -= f.y; forces[c].z -= f.z;
      }
      // nonbonded repulsion
      for(let i=0;i<n;i++){
        for(let j=i+1;j<n;j++){
          let bonded = false;
          for(const b of bonds) if((b.a===i && b.b===j) || (b.a===j && b.b===i)) { bonded = true; break; }
          if(bonded) continue;
          const rvec = { x: pos[j].x - pos[i].x, y: pos[j].y - pos[i].y, z: pos[j].z - pos[i].z };
          const dist = Math.hypot(rvec.x, rvec.y, rvec.z) + 1e-9;
          const sigma = (covalentRadii[atomsList[i]] || 0.9) + (covalentRadii[atomsList[j]] || 0.9);
          const rr = Math.pow((sigma + 1e-9) / dist, 12);
          const fmag = nonbondEps * rr;
          const dir = { x: rvec.x / dist, y: rvec.y / dist, z: rvec.z / dist };
          const f = { x: dir.x * fmag, y: dir.y * fmag, z: dir.z * fmag };
          forces[i].x -= f.x; forces[i].y -= f.y; forces[i].z -= f.z;
          forces[j].x += f.x; forces[j].y += f.y; forces[j].z += f.z;
        }
      }
      // integrate
      let maxDisp = 0;
      for(let i=0;i<n;i++){
        const acc = { x: forces[i].x / masses[i], y: forces[i].y / masses[i], z: forces[i].z / masses[i] };
        vel[i].x += acc.x * dt; vel[i].y += acc.y * dt; vel[i].z += acc.z * dt;
        vel[i].x *= (1 - damping); vel[i].y *= (1 - damping); vel[i].z *= (1 - damping);
        pos[i].x += vel[i].x * dt; pos[i].y += vel[i].y * dt; pos[i].z += vel[i].z * dt;
        const disp = Math.hypot(vel[i].x * dt, vel[i].y * dt, vel[i].z * dt);
        if(disp > maxDisp) maxDisp = disp;
      }
      if(maxDisp < 1e-4) break;
    }
    return pos;
  }

  // Rendering
  function renderStatic(atomsList, bonds, positions) {
    viewer.clear();
    const showLabels = document.getElementById('showLabels').checked;
    const showBonds = document.getElementById('showBonds').checked;
    const showNuclei = document.getElementById('showNuclei').checked;
    const lowQ = document.getElementById('lowQuality').checked;

    if(showNuclei) {
      for(let i=0;i<atomsList.length;i++){
        const p = positions[i];
        viewer.addSphere({ center: p, radius: 0.30, color: '#FF0000', alpha: 0.36 });
      }
    }

    for(let i=0;i<atomsList.length;i++){
      const el = atomsList[i];
      const p = positions[i];
      const col = elementColors[el] || '#CCCCCC';
      const baseR = (covalentRadii[el] || 0.8) * 0.28;
      const radius = lowQ ? baseR * 0.85 : baseR;
      viewer.addSphere({ center: p, radius: radius, color: col, alpha: 1.0 });
      if(showLabels) viewer.addLabel(el, { position: p, backgroundColor: 'rgba(0,0,0,0.6)', fontColor:'#fff', fontSize:12 });
    }

    if(showBonds) {
      const cylR = lowQ ? 0.06 : 0.09;
      for(const b of bonds) {
        const pa = positions[b.a], pb = positions[b.b];
        viewer.addCylinder({ start: pa, end: pb, radius: cylR, color: '#cfcfcf' });
      }
    }

    viewer.zoomTo();
    viewer.render();
  }

  // Full pipeline with error handling
  function buildAndRenderFromFormula(formula) {
    try {
      const atomsList = parseFormula(formula);
      if(!atomsList) { alert('Could not parse formula. Use standard chemical formulas only. Examples: H2O NH3 CH4 CO2 C6H6 C2H5OH'); return; }

      const conn = buildConnectivity(atomsList);
      let bonds = conn.bonds;

      // ensure rest lengths set
      for(let i=0;i<bonds.length;i++){
        if(!bonds[i].rest){
          const a = atomsList[bonds[i].a], b = atomsList[bonds[i].b];
          bonds[i].rest = (covalentRadii[a] || 0.9) + (covalentRadii[b] || 0.9);
          bonds[i].rest *= 0.95;
        }
      }

      const initialPositions = placeInitialGeometry(atomsList, bonds);
      const finalPositions = relaxGeometry(atomsList, bonds, initialPositions);
      renderStatic(atomsList, bonds, finalPositions);
    } catch(err) {
      console.error('buildAndRender error', err);
      alert('An unexpected error occurred while rendering. Check the console for details and paste the formula here if it fails again.');
    }
  }

  // UI hooks
  document.getElementById('confirmBtn').addEventListener('click', () => {
    const s = document.getElementById('molInput').value.trim();
    buildAndRenderFromFormula(s);
  });
  document.getElementById('examplesBtn').addEventListener('click', () => {
    const ex = ['NH3','H2O','CH4','CO2','C6H6','C2H5OH','C2H4','C2H2','H2','O2','N2'];
    const pick = prompt('Type example formula:' + '\n' + ex.join(', '), 'NH3');
    if(pick) document.getElementById('molInput').value = pick;
  });

  ['showLabels','showBonds','showNuclei','lowQuality'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      const cur = document.getElementById('molInput').value.trim();
      if(cur) buildAndRenderFromFormula(cur);
    });
  });

  // initial render of NH3
  setTimeout(()=>{ buildAndRenderFromFormula(document.getElementById('molInput').value); }, 120);

  window.addEventListener('resize', () => {
    viewer.setSize(document.getElementById('viewer').clientWidth, document.getElementById('viewer').clientHeight);
    viewer.render();
  });
  </script>
</body>
</html>
