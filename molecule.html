<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Molecule Simulator - Formula Only</title>
  <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
  <style>
    :root {
      --panel-w:320px;
      --bg:#000000;
      --panel-bg:#08101a;
      --muted:#9dbadf;
      --accent:#12a4ff;
      --ui:#e6eef8;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;}
    #app{display:flex;height:100vh;}
    #controls{width:var(--panel-w);min-width:260px;padding:18px;box-sizing:border-box;background:var(--panel-bg);border-right:1px solid rgba(255,255,255,0.03);overflow:auto;}
    #viewer{flex:1;position:relative;}
    h1{margin:0 0 8px 0;font-size:18px;color:var(--accent);}
    label{display:block;margin-top:12px;font-size:13px;color:var(--muted);}
    input[type=text]{width:100%;padding:9px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#071023;color:var(--ui);box-sizing:border-box;margin-top:8px;}
    button{margin-top:12px;padding:9px 12px;border-radius:8px;border:0;cursor:pointer;background:var(--accent);color:#002234;font-weight:600;}
    .toggles{margin-top:12px;display:flex;flex-direction:column;gap:8px;}
    .toggle{display:flex;align-items:center;gap:8px;}
    .small{font-size:12px;color:var(--muted);}
    .footer{margin-top:14px;font-size:12px;color:var(--muted);}
    .note{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.3;}
    a{color:var(--accent);text-decoration:none;}
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <h1>Molecule Simulator - Formula Only</h1>

      <label>Enter chemical formula only</label>
      <input id="molInput" value="NH3" placeholder="Examples: H2O, NH3, CH4, CO2, C6H6, C2H5OH" />

      <div style="display:flex;gap:8px;">
        <button id="confirmBtn">Render</button>
        <button id="examplesBtn">Examples</button>
      </div>

      <div class="toggles">
        <div class="toggle"><input id="showLabels" type="checkbox" checked> <label for="showLabels" class="small">Show labels</label></div>
        <div class="toggle"><input id="showBonds" type="checkbox" checked> <label for="showBonds" class="small">Show bonds</label></div>
        <div class="toggle"><input id="showNuclei" type="checkbox" checked> <label for="showNuclei" class="small">Show nuclei (red transparent)</label></div>
        <div class="toggle"><input id="lowQuality" type="checkbox"> <label for="lowQuality" class="small">Low quality for performance</label></div>
      </div>

      <div class="note">
        This tool accepts chemical formulas only. It builds connectivity based on valence heuristics and covalent radii, then computes a stable 3D geometry via a careful relaxation step. The result is static and stable for viewing and export.
      </div>

      <div class="footer small">
        If you want extra molecules added to a built in precise database, tell me which ones and I will add them.
      </div>
    </div>

    <div id="viewer"></div>
  </div>

  <script>
  // Universal formula-only molecule visualizer
  // Parsing, bonding, 3D initial placement, and careful relaxation to a static geometry
  // All text and UI uses hyphens, no em-dash characters

  const viewer = $3Dmol.createViewer('viewer',{backgroundColor:'black',antialias:true});
  viewer.setBackgroundColor(0x000000);

  // Element visual data
  const elementColors = {
    H:'#FFFFFF', C:'#909090', N:'#3050F8', O:'#FF0D0D', F:'#90E050', Cl:'#1FF01F', S:'#FFFF30', P:'#FFA500',
    Li:'#CC80FF', Na:'#AB5CF2', Mg:'#8AFF00', Br:'#A62929', I:'#940094'
  };
  const covalentRadii = { H:0.31, C:0.76, N:0.71, O:0.66, F:0.57, P:1.07, S:1.05, Cl:1.02, Br:1.2, I:1.39 };

  // Typical valences for bonding heuristics
  const valences = { H:1, He:0, Li:1, Be:2, B:3, C:4, N:3, O:2, F:1, Ne:0, Na:1, Mg:2, Al:3, Si:4, P:3, S:2, Cl:1, Br:1, I:1 };

  // Parse chemical formula like C6H6 or H2O
  function parseFormula(formula) {
    if(!formula) return null;
    const s = formula.trim();
    // allow only letters and numbers and parentheses
    if(!/^[A-Za-z0-9()]+$/.test(s)) return null;
    // Expand groups with parentheses e.g. (CH3)2CH -> not full parser, we support simple cases
    // For simplicity implement basic parenthesis handling
    function expandParens(str) {
      // handle nested parentheses by using a loop
      while(true) {
        const m = str.match(/\(([A-Za-z0-9]+)\)(\d+)/);
        if(!m) break;
        const group = m[1], count = parseInt(m[2]||'1');
        let rep = '';
        for(let i=0;i<count;i++) rep += group;
        str = str.replace(m[0], rep);
      }
      return str;
    }
    let expanded = expandParens(s);
    // Now capture element symbols and counts
    const re = /([A-Z][a-z]?)(\d*)/g;
    let m; const atoms = [];
    while((m = re.exec(expanded)) !== null) {
      const el = m[1];
      const cnt = m[2] ? parseInt(m[2]) : 1;
      for(let i=0;i<cnt;i++) atoms.push(el);
    }
    if(atoms.length === 0) return null;
    return atoms;
  }

  // Build connectivity using greedy algorithm using covalent radii and valence limits
  function buildConnectivity(atoms) {
    const n = atoms.length;
    const coords = []; // initial positions will be assigned later
    for(let i=0;i<n;i++){
      coords.push({x:Math.random()*0.8 - 0.4, y:Math.random()*0.8 - 0.4, z:Math.random()*0.8 - 0.4});
    }
    // compute candidate pairs sorted by radius-based target length
    const candidates = [];
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const ri = covalentRadii[atoms[i]] || 0.9;
        const rj = covalentRadii[atoms[j]] || 0.9;
        const target = (ri + rj) * 0.95; // approximate desired bond length
        candidates.push({i,j,target});
      }
    }
    // sort by target ascending to prefer shorter bonds first
    candidates.sort((a,b) => a.target - b.target);

    const bonds = [];
    const remainingValence = atoms.map(el => valences[el] != null ? valences[el] : 1);

    for(const c of candidates){
      if(remainingValence[c.i] > 0 && remainingValence[c.j] > 0) {
        // Accept bond based on valence and a heuristic probability that avoids overbonding heavy atoms
        bonds.push({a:c.i, b:c.j, rest: c.target});
        remainingValence[c.i]--; remainingValence[c.j]--;
      }
    }

    // Ensure connectivity: if graph is disconnected try to connect components by closest pairs ignoring valence
    function findParent(par) {
      if(par[p] === p) return p;
    }
    // Quick union find to check components
    const parent = Array.from({length:n}, (_,i)=>i);
    function find(x){ return parent[x]===x ? x : (parent[x]=find(parent[x])); }
    function unify(a,b){ const ra=find(a), rb=find(b); if(ra!==rb) parent[ra]=rb; }
    bonds.forEach(b => unify(b.a, b.b));
    const comps = new Map();
    for(let i=0;i<n;i++){ const r=find(i); if(!comps.has(r)) comps.set(r, []); comps.get(r).push(i); }
    if(comps.size > 1) {
      const reps = Array.from(comps.values()).map(c=>c[0]);
      for(let i=0;i<reps.length-1;i++){
        const a = reps[i], b = reps[i+1];
        const ri = covalentRadii[atoms[a]] || 0.9, rj = covalentRadii[atoms[b]] || 0.9;
        bonds.push({a, b, rest: (ri+rj)*0.95});
      }
    }

    return { bonds, coords };
  }

  // Place atoms initial positions by a simple BFS placement starting from heaviest atom
  function placeInitialGeometry(atoms, bonds) {
    const n = atoms.length;
    const positions = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
    const deg = Array.from({length:n}, ()=>0);
    bonds.forEach(b => { deg[b.a]++; deg[b.b]++; });

    // choose root as atom with highest degree or heaviest element via covalent radius
    let root = 0;
    let bestScore = -Infinity;
    for(let i=0;i<n;i++){
      const score = deg[i] * 2 + (covalentRadii[atoms[i]] || 0);
      if(score > bestScore){ bestScore = score; root = i; }
    }

    const visited = new Array(n).fill(false);
    const adj = Array.from({length:n}, ()=>[]);
    bonds.forEach(b => { adj[b.a].push(b.b); adj[b.b].push(b.a); });

    // BFS seed
    positions[root] = {x:0,y:0,z:0};
    visited[root] = true;
    const queue = [root];

    while(queue.length){
      const cur = queue.shift();
      const neighbors = adj[cur];
      // determine spacing based on neighbor bond lengths
      for(let k=0;k<neighbors.length;k++){
        const nb = neighbors[k];
        if(visited[nb]) continue;
        // angle distribution using golden angle to avoid overlap
        const phi = (k+1) * 2.399963229728653; // golden angle in radians
        const radius = (covalentRadii[atoms[cur]]||0.9) + (covalentRadii[atoms[nb]]||0.9);
        const r = radius * 0.95;
        // place relative to cur in spherical coordinates
        const x = positions[cur].x + r * Math.cos(phi) * (1 + 0.15*(Math.random()-0.5));
        const y = positions[cur].y + r * Math.sin(phi) * (1 + 0.15*(Math.random()-0.5));
        const z = positions[cur].z + (0.2 * (k - neighbors.length/2)) * (1 + 0.2*(Math.random()-0.5));
        positions[nb] = {x,y,z};
        visited[nb] = true;
        queue.push(nb);
      }
    }

    // For any isolated atoms not reached, scatter them
    for(let i=0;i<n;i++){
      if(!visited[i]) positions[i] = {x:(Math.random()-0.5)*1.2, y:(Math.random()-0.5)*1.2, z:(Math.random()-0.5)*1.2};
    }

    return positions;
  }

  // Relaxation to minimize bond spring energy and short-range repulsion
  // This runs until convergence and then stops, producing a static geometry
  function relaxGeometry(atomsList, bonds, positions) {
    const n = atomsList.length;
    const maxIter = 3000;
    const dt = 0.02; // time step
    const kBond = 120.0; // bond stiffness strong to keep bonds in length
    const nonbondEps = 0.08; // repulsion strength
    const damping = 0.35; // velocity damping large for stability
    const masses = atomsList.map(el => (covalentRadii[el]||0.9) * 10 + 1);
    const vel = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
    const restLen = bonds.map(b => b.rest || ((covalentRadii[atomsList[b.a]]||0.9) + (covalentRadii[atomsList[b.b]]||0.9))*0.95);
    // convert positions to float arrays
    const pos = positions.map(p => ({x:p.x, y:p.y, z:p.z}));

    let converged = false;
    for(let iter=0; iter<maxIter; iter++){
      // zero forces
      const forces = Array.from({length:n}, ()=>({x:0,y:0,z:0}));
      // bond forces
      for(let bi=0; bi<bonds.length; bi++){
        const b = bonds[bi];
        const a = b.a, c = b.b;
        const rvec = { x: pos[c].x - pos[a].x, y: pos[c].y - pos[a].y, z: pos[c].z - pos[a].z };
        const dist = Math.hypot(rvec.x, rvec.y, rvec.z) + 1e-9;
        const dir = { x: rvec.x / dist, y: rvec.y / dist, z: rvec.z / dist };
        const diff = dist - restLen[bi];
        const fmag = -kBond * diff;
        const f = { x: dir.x * fmag, y: dir.y * fmag, z: dir.z * fmag };
        forces[a].x += f.x; forces[a].y += f.y; forces[a].z += f.z;
        forces[c].x -= f.x; forces[c].y -= f.y; forces[c].z -= f.z;
      }
      // nonbonded short range repulsion
      for(let i=0;i<n;i++){
        for(let j=i+1;j<n;j++){
          // skip if bonded
          let bonded = false;
          for(let b of bonds) if((b.a===i && b.b===j) || (b.a===j && b.b===i)) { bonded = true; break; }
          if(bonded) continue;
          const rvec = { x: pos[j].x - pos[i].x, y: pos[j].y - pos[i].y, z: pos[j].z - pos[i].z };
          const dist = Math.hypot(rvec.x, rvec.y, rvec.z) + 1e-9;
          const sigma = (covalentRadii[atomsList[i]] || 0.9) + (covalentRadii[atomsList[j]] || 0.9);
          // use repulsive term proportional to (sigma/dist)^12 but scaled down
          const rr = Math.pow((sigma+1e-9) / dist, 12);
          const fmag = nonbondEps * rr;
          const dir = { x: rvec.x / dist, y: rvec.y / dist, z: rvec.z / dist };
          const f = { x: dir.x * fmag, y: dir.y * fmag, z: dir.z * fmag };
          forces[i].x -= f.x; forces[i].y -= f.y; forces[i].z -= f.z;
          forces[j].x += f.x; forces[j].y += f.y; forces[j].z += f.z;
        }
      }
      // integrate velocities and positions semi-implicitly
      let maxDisp = 0;
      for(let i=0;i<n;i++){
        const acc = { x: forces[i].x / masses[i], y: forces[i].y / masses[i], z: forces[i].z / masses[i] };
        vel[i].x += acc.x * dt; vel[i].y += acc.y * dt; vel[i].z += acc.z * dt;
        // damping
        vel[i].x *= (1 - damping);
        vel[i].y *= (1 - damping);
        vel[i].z *= (1 - damping);
        // position update
        pos[i].x += vel[i].x * dt;
        pos[i].y += vel[i].y * dt;
        pos[i].z += vel[i].z * dt;
        const disp = Math.hypot(vel[i].x * dt, vel[i].y * dt, vel[i].z * dt);
        if(disp > maxDisp) maxDisp = disp;
      }
      // convergence criterion: max displacement small
      if(maxDisp < 1e-4) { converged = true; break; }
    }
    // return positions
    return pos;
  }

  // Render static structure using 3Dmol
  function renderStatic(atomsList, bonds, positions) {
    viewer.clear();
    const showLabels = document.getElementById('showLabels').checked;
    const showBonds = document.getElementById('showBonds').checked;
    const showNuclei = document.getElementById('showNuclei').checked;
    const lowQ = document.getElementById('lowQuality').checked;

    // nuclei in red transparent under atoms
    if(showNuclei) {
      for(let i=0;i<atomsList.length;i++){
        const p = positions[i];
        viewer.addSphere({ center: p, radius: 0.30, color: '#FF0000', alpha: 0.36 });
      }
    }

    for(let i=0;i<atomsList.length;i++){
      const el = atomsList[i];
      const p = positions[i];
      const col = elementColors[el] || '#CCCCCC';
      const baseR = (covalentRadii[el] || 0.8) * 0.28;
      const radius = lowQ ? baseR * 0.85 : baseR;
      viewer.addSphere({ center: p, radius: radius, color: col, alpha: 1.0 });
      if(showLabels) viewer.addLabel(el, { position: p, backgroundColor: 'rgba(0,0,0,0.6)', fontColor:'#fff', fontSize:12 });
    }

    if(showBonds) {
      const cylR = lowQ ? 0.06 : 0.09;
      for(const b of bonds) {
        const pa = positions[b.a], pb = positions[b.b];
        viewer.addCylinder({ start: pa, end: pb, radius: cylR, color: '#cfcfcf' });
      }
    }

    viewer.zoomTo();
    viewer.render();
  }

  // Main pipeline: parse formula, build connectivity, initial placement, relax, render static
  function buildAndRenderFromFormula(formula) {
    const atomsList = parseFormula(formula);
    if(!atomsList) { alert('Could not parse formula. Use standard chemical formulas only. Examples: H2O NH3 CH4 CO2 C6H6 C2H5OH'); return; }

    // Build connectivity
    const conn = buildConnectivity(atomsList);
    const bonds = conn.bonds;

    // Place initial geometry
    const initialPositions = placeInitialGeometry(atomsList, bonds);

    // Assign rest lengths for bonds if missing
    for(let i=0;i<bonds.length;i++){
      if(!bonds[i].rest) {
        const a = atomsList[bonds[i].a], b = atomsList[bonds[i].b];
        const ra = covalentRadii[a] || 0.9, rb = covalentRadii[b] || 0.9;
        bonds[i].rest = (ra + rb) * 0.95;
      }
    }

    // Relaxation to stable static coordinates
    const finalPositions = relaxGeometry(atomsList, bonds, initialPositions);

    // Render
    renderStatic(atomsList, bonds, finalPositions);
  }

  // UI hooks
  document.getElementById('confirmBtn').addEventListener('click', () => {
    const s = document.getElementById('molInput').value.trim();
    buildAndRenderFromFormula(s);
  });
  document.getElementById('examplesBtn').addEventListener('click', () => {
    const ex = ['NH3','H2O','CH4','CO2','C6H6','C2H5OH','C2H4','C2H2','H2','O2','N2'];
    const pick = prompt('Type example formula:' + '\n' + ex.join(', '), 'NH3');
    if(pick) document.getElementById('molInput').value = pick;
  });

  // Toggles re-render from current formula
  ['showLabels','showBonds','showNuclei','lowQuality'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      const cur = document.getElementById('molInput').value.trim();
      if(cur) buildAndRenderFromFormula(cur);
    });
  });

  // initial render
  setTimeout(()=>{ buildAndRenderFromFormula(document.getElementById('molInput').value); }, 120);

  // responsive
  window.addEventListener('resize', () => {
    viewer.setSize(document.getElementById('viewer').clientWidth, document.getElementById('viewer').clientHeight);
    viewer.render();
  });
  </script>
</body>
</html>
