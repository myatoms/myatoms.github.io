<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Molecule Simulator — Accurate Static Geometries</title>
  <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
  <style>
    :root {
      --panel-w: 320px;
      --bg: #000000;
      --panel-bg: #0b1220;
      --muted: #9dbadf;
      --accent: #12a4ff;
      --ui-fg: #e6eef8;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--ui-fg); font-family: "Segoe UI", Roboto, Arial, sans-serif; }
    #app { height:100vh; display:flex; }
    #controls {
      width:var(--panel-w);
      min-width:260px;
      box-sizing:border-box;
      padding:18px;
      background:var(--panel-bg);
      border-right:1px solid rgba(255,255,255,0.03);
      overflow:auto;
    }
    #viewer { flex:1; position:relative; }
    h1 { margin:0; font-size:18px; color:var(--accent); }
    label { display:block; margin-top:12px; font-size:13px; color:var(--muted); }
    input[type=text] { width:100%; padding:8px 10px; margin-top:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#071023; color:var(--ui-fg); box-sizing:border-box; }
    button { margin-top:12px; padding:9px 12px; border-radius:8px; border:0; cursor:pointer; background:var(--accent); color:#002234; font-weight:600; }
    .toggles { margin-top:12px; display:flex; flex-direction:column; gap:8px; }
    .toggle { display:flex; align-items:center; gap:8px; }
    .small { font-size:12px; color:var(--muted); }
    .footer { margin-top:14px; font-size:12px; color:var(--muted); }
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <h1>Molecule Simulator — Accurate Geometries</h1>
      <label>Enter molecule name or formula</label>
      <input id="molInput" value="NH3" placeholder="e.g. H2O, NH3, CH4, CO2, benzene, ethanol" />
      <div style="display:flex; gap:8px;">
        <button id="confirmBtn">Confirm & Render</button>
        <button id="examplesBtn">Examples</button>
      </div>

      <div class="toggles">
        <div class="toggle"><input type="checkbox" id="showLabels" checked> <label for="showLabels" class="small">Show element labels</label></div>
        <div class="toggle"><input type="checkbox" id="showBonds" checked> <label for="showBonds" class="small">Show bonds</label></div>
        <div class="toggle"><input type="checkbox" id="showNuclei" checked> <label for="showNuclei" class="small">Show nuclei (red, semi-transparent)</label></div>
        <div class="toggle"><input type="checkbox" id="lowQuality"> <label for="lowQuality" class="small">Low quality (faster)</label></div>
      </div>

      <div class="footer">
        <div class="small"><strong>Supported precise examples:</strong> H2, O2, N2, H2O, NH3, CH4, CO2, CH3OH (methanol), C2H6 (ethane), C2H4 (ethylene), C2H2 (acetylene), benzene.</div>
        <div style="margin-top:8px;" class="small">If you want *additional molecules* (exact geometries from crystallography or quantum calculations), tell me which and I will add them.</div>
        <div style="margin-top:12px;" class="small">University-style — static, accurate, and efficient.</div>
      </div>
    </div>

    <div id="viewer"></div>
  </div>

  <script>
    /**************************************************************************
     * Static, accurate-ish geometries for common molecules (idealized values)
     *
     * Units: coordinates in Angstroms. These are textbook/ideal geometries,
     * enough for educational & visualization use.
     *
     * If molecule not found, fallback to a simple chain/ring generator.
     **************************************************************************/

    // 3Dmol viewer (black background)
    const viewer = $3Dmol.createViewer('viewer', { backgroundColor: 'black', antialias: true });
    const scaling = 1.0; // 1 Å => 1 viewer unit

    // element colors (informational, standard CPK-ish)
    const elementColors = {
      H:'#FFFFFF', C:'#909090', N:'#3050F8', O:'#FF0D0D', F:'#90E050', Cl:'#1FF01F', S:'#FFFF30', P:'#FFA500',
      Li:'#CC80FF', Na:'#AB5CF2', Mg:'#8AFF00', Br:'#A62929', I:'#940094'
    };
    const defaultColor = '#CCCCCC';

    // covalent radii for drawing spheres
    const covalentRadii = { H:0.31, C:0.76, N:0.71, O:0.66, F:0.57, P:1.07, S:1.05, Cl:1.02 };

    // Small molecule geometry database (idealized)
    // Each entry: { atoms: [{elem, x,y,z}, ...], bonds: [[i,j,order?], ...] }
    const geometryDB = {
      // Dihydrogen (H2)
      'H2': {
        atoms:[ {elem:'H', x:-0.37, y:0, z:0}, {elem:'H', x:0.37, y:0, z:0} ], // ~0.74 Å separation
        bonds:[[0,1]]
      },
      'O2': {
        atoms:[ {elem:'O', x:-0.6, y:0, z:0}, {elem:'O', x:0.6, y:0, z:0} ], // ~1.21 Å
        bonds:[[0,1]]
      },
      'N2': {
        atoms:[ {elem:'N', x:-0.6, y:0, z:0}, {elem:'N', x:0.6, y:0, z:0} ], // ~1.10 Å
        bonds:[[0,1]]
      },

      // Water (H2O) — bent ~104.5°, O-H = 0.958 Å
      'H2O': {
        atoms:[
          {elem:'O', x:0, y:0, z:0},
          // placed in xy-plane with angle ±52.25°
          {elem:'H', x: Math.cos(52.25*Math.PI/180)*0.958, y: Math.sin(52.25*Math.PI/180)*0.958, z:0},
          {elem:'H', x: Math.cos(52.25*Math.PI/180)*0.958, y: -Math.sin(52.25*Math.PI/180)*0.958, z:0}
        ],
        bonds:[[0,1],[0,2]]
      },

      // Ammonia (NH3) — trigonal pyramidal with N at center, N-H ≈ 1.01 Å, H-N-H ~107°
      'NH3': {
        atoms:(() => {
          // Use three tetrahedral directions to approximate trigonal pyramidal geometry.
          const r = 1.01;
          const tv = [
            [  1,  1,  1 ],
            [  1, -1, -1 ],
            [ -1,  1, -1 ],
            [ -1, -1,  1 ]
          ];
          // pick first three as H positions, N at origin
          function norm(v){ const n=Math.hypot(v[0],v[1],v[2]); return [v[0]/n, v[1]/n, v[2]/n]; }
          const hpos = [norm(tv[0]), norm(tv[1]), norm(tv[2])].map(u => ({ x: u[0]*r, y: u[1]*r, z: u[2]*r }));
          return [{elem:'N', x:0,y:0,z:0}, {elem:'H', ...hpos[0]}, {elem:'H', ...hpos[1]}, {elem:'H', ...hpos[2]}];
        })(),
        bonds:[[0,1],[0,2],[0,3]]
      },

      // Methane (CH4) — tetrahedral, C-H ≈ 1.09 Å
      'CH4': {
        atoms:(() => {
          const r = 1.09;
          const verts = [
            [ 1, 1, 1 ],
            [ 1,-1,-1 ],
            [-1, 1,-1 ],
            [-1,-1, 1 ]
          ];
          function norm(v){ const n=Math.hypot(v[0],v[1],v[2]); return [v[0]/n, v[1]/n, v[2]/n]; }
          const hs = verts.map(v => { const u = norm(v); return {elem:'H', x:u[0]*r, y:u[1]*r, z:u[2]*r}; });
          return [ {elem:'C', x:0,y:0,z:0}, ...hs ];
        })(),
        bonds:[[0,1],[0,2],[0,3],[0,4]]
      },

      // Carbon dioxide (CO2) — linear, C=O ≈ 1.16 Å
      'CO2': {
        atoms:[ {elem:'O', x:-1.16, y:0, z:0}, {elem:'C', x:0,y:0,z:0}, {elem:'O', x:1.16,y:0,z:0} ],
        bonds:[[0,1],[1,2]]
      },

      // Methanol (CH3OH) — approximate idealized geometry
      'CH3OH': {
        atoms:(() => {
          // Place C-C-O chain style: actually CH3-O-H
          // C at origin, three H tetrahedral, O along +x, O-H bond
          const c_h = 1.09, c_o = 1.43, o_h = 0.96;
          const verts = [
            [1,1,1], [1,-1,-1], [-1,1,-1]
          ];
          function norm(v){ const n=Math.hypot(v[0],v[1],v[2]); return [v[0]/n, v[1]/n, v[2]/n]; }
          const hs = verts.map(v => { const u=norm(v); return {elem:'H', x:u[0]*c_h, y:u[1]*c_h, z:u[2]*c_h}; });
          // O at +x direction
          const ox = {elem:'O', x:c_o, y:0, z:0};
          const oh = {elem:'H', x:c_o + o_h*Math.cos(104.5*Math.PI/180), y: o_h*Math.sin(104.5*Math.PI/180), z:0};
          return [ {elem:'C', x:0,y:0,z:0}, ...hs, ox, oh ];
        })(),
        bonds:[[0,1],[0,2],[0,3],[0,4],[4,5]] // note: 4 is O index maybe, adjust below when building
      },

      // Ethane C2H6 (approx)
      'C2H6': {
        atoms:(() => {
          const c_c = 1.54, c_h = 1.09;
          // two carbons along x
          const c1 = {elem:'C', x:-c_c/2, y:0, z:0};
          const c2 = {elem:'C', x:c_c/2, y:0, z:0};
          // attach three H around each carbon (approx tetrahedral)
          const v1 = [[1,1,1],[1,-1,-1],[-1,1,-1]];
          const v2 = [[-1,-1,1],[-1,1,-1],[1,-1,-1]];
          function norm(v){ const n=Math.hypot(v[0],v[1],v[2]); return [v[0]/n, v[1]/n, v[2]/n]; }
          const h1 = v1.map(v => { const u=norm(v); return {elem:'H', x:c1.x + u[0]*c_h, y:u[1]*c_h, z:u[2]*c_h}; });
          const h2 = v2.map(v => { const u=norm(v); return {elem:'H', x:c2.x + u[0]*c_h, y:u[1]*c_h, z:u[2]*c_h}; });
          return [c1, c2, ...h1, ...h2];
        })(),
        bonds:[] // we'll compute bonds from atoms positions
      },

      // Ethylene C2H4 (approx planar)
      'C2H4': {
        atoms:(() => {
          const c_c = 1.34, c_h = 1.09;
          const c1 = {elem:'C', x:-c_c/2, y:0, z:0};
          const c2 = {elem:'C', x:c_c/2, y:0, z:0};
          const h1 = {elem:'H', x:-c_c/2, y: c_h, z:0};
          const h2 = {elem:'H', x:-c_c/2, y:-c_h, z:0};
          const h3 = {elem:'H', x:c_c/2, y: c_h, z:0};
          const h4 = {elem:'H', x:c_c/2, y:-c_h, z:0};
          return [c1,c2,h1,h2,h3,h4];
        })(),
        bonds:[]
      },

      // Acetylene C2H2 (linear)
      'C2H2': {
        atoms:[
          {elem:'H', x:-1.20-1.06, y:0, z:0}, // H — C ≈ 1.06
          {elem:'C', x:-1.20/2, y:0, z:0},
          {elem:'C', x:1.20/2, y:0, z:0},
          {elem:'H', x:1.20 + 1.06, y:0, z:0}
        ],
        bonds:[[0,1],[1,2],[2,3]]
      },

      // Benzene (C6H6) — planar hexagon approx
      'C6H6': {
        atoms:(() => {
          const cc = 1.397; // approx C-C in benzene (Å)
          const r = cc / (2*Math.sin(Math.PI/6)); // radius of hexagon
          const atoms = [];
          for(let i=0;i<6;i++){
            const theta = i * Math.PI*2 / 6;
            atoms.push({elem:'C', x: r*Math.cos(theta), y: r*Math.sin(theta), z:0});
          }
          // add H atoms radially outwards
          for(let i=0;i<6;i++){
            const theta = i * Math.PI*2 / 6;
            const cx = atoms[i].x, cy = atoms[i].y;
            const hx = cx + Math.cos(theta)*1.09;
            const hy = cy + Math.sin(theta)*1.09;
            atoms.push({elem:'H', x:hx, y:hy, z:0});
          }
          return atoms;
        })(),
        bonds:[]
      }
    };

    // Normalize keys for DB (allow multiple synonyms)
    const synonyms = {
      'water':'H2O', 'dihydrogen oxide':'H2O',
      'methane':'CH4', 'ammonia':'NH3', 'carbon dioxide':'CO2', 'methanol':'CH3OH', 'ethanol':'C2H5OH', 'benzene':'C6H6'
    };

    /**********************
     * Utility functions
     **********************/
    function parseInput(raw) {
      if(!raw) return null;
      let s = raw.trim();
      const lower = s.toLowerCase();
      if(synonyms[lower]) s = synonyms[lower];
      // allow names that directly match DB keys
      if(geometryDB[s]) return { key: s, data:geometryDB[s] };

      // Try to normalize formulas like h2o -> H2O
      const compact = s.replace(/\s+/g,'');
      // If compact contains letters/numbers only, standardize to element-case
      if(/^[A-Za-z0-9]+$/.test(compact)) {
        // capitalize element symbols: pattern: letter then optional lowercase, then optional digits
        const re = /([A-Za-z]{1,2})(\d*)/g;
        let standardized = '';
        let m;
        while((m = re.exec(compact)) !== null) {
          let el = m[1];
          if(el.length === 1) el = el.toUpperCase();
          else el = el[0].toUpperCase() + el[1].toLowerCase();
          standardized += el + (m[2]||'');
        }
        if(geometryDB[standardized]) return { key: standardized, data: geometryDB[standardized] };
        // else return expanded atom list for fallback generator
        return { key: standardized, data: null };
      }
      return null;
    }

    function euclid(a,b){ return Math.hypot(a.x-b.x, a.y-b.y, a.z-b.z); }

    // Build atoms + bonds from geometryDB entry or fallback chain/ring
    function buildFromData(key, data) {
      if(data) {
        // If bonds list empty or partial, auto-compute using distance & covalent radii
        const atoms = data.atoms.map(a => ({ elem: a.elem, pos:{ x:a.x*scaling, y:a.y*scaling, z:(a.z||0)*scaling } }));
        let bonds = (data.bonds && data.bonds.length>0) ? data.bonds.map(b => ({a:b[0], b:b[1]})) : [];
        if(bonds.length === 0) {
          // auto-detect bonds by distance thresholds
          for(let i=0;i<atoms.length;i++){
            for(let j=i+1;j<atoms.length;j++){
              const ri = covalentRadii[atoms[i].elem] || 0.9;
              const rj = covalentRadii[atoms[j].elem] || 0.9;
              const cutoff = (ri + rj) * 1.25; // tolerance factor
              if(euclid(atoms[i].pos, atoms[j].pos) < cutoff) bonds.push({a:i,b:j});
            }
          }
        }
        return { atoms, bonds };
      } else {
        // fallback: parse formula and make a simple chain/ring with reasonable bond lengths
        const standardized = key;
        const re = /([A-Z][a-z]?)(\d*)/g;
        let m; let list = [];
        while((m = re.exec(standardized)) !== null) {
          const el = m[1];
          const cnt = m[2] ? parseInt(m[2]) : 1;
          for(let i=0;i<cnt;i++) list.push(el);
        }
        // place chain along x-axis with typical single-bond length (C-C or C-H etc)
        const defaultBond = 1.5;
        const atoms = list.map((el,i) => ({ elem: el, pos: { x:(i - (list.length-1)/2)*defaultBond, y:0, z:0 } }));
        const bonds = [];
        for(let i=0;i<list.length-1;i++) bonds.push({a:i,b:i+1});
        return { atoms, bonds };
      }
    }

    /**********************
     * Rendering functions
     **********************/
    function renderStructure(struct, opts = {}) {
      viewer.removeAllLabels();
      viewer.removeAllShapes();

      const showLabels = document.getElementById('showLabels').checked;
      const showBonds = document.getElementById('showBonds').checked;
      const showNuclei = document.getElementById('showNuclei').checked;
      const lowQ = document.getElementById('lowQuality').checked;

      // Nuclei — red semi-transparent spheres under atoms
      if(showNuclei) {
        for(let i=0;i<struct.atoms.length;i++) {
          const a = struct.atoms[i];
          viewer.addSphere({ center: a.pos, radius: 0.30, color:'#FF0000', alpha: 0.38, wireframe:false, clickable:false });
        }
      }

      // Atom spheres
      for(let i=0;i<struct.atoms.length;i++){
        const a = struct.atoms[i];
        const col = elementColors[a.elem] || defaultColor;
        // visual radius: use covalent radius scaled; for H we keep slightly visible
        const baseR = (covalentRadii[a.elem] || 0.8) * 0.26;
        const radius = lowQ ? baseR*0.85 : baseR;
        viewer.addSphere({ center: a.pos, radius: radius, color: col, alpha:1.0 });
        if(showLabels) {
          viewer.addLabel(a.elem, { position: a.pos, backgroundColor:'rgba(0,0,0,0.6)', fontColor:'#fff', fontSize:12 });
        }
      }

      // Bonds (cylinders)
      if(showBonds) {
        const cylRadius = lowQ ? 0.06 : 0.09;
        for(let b of struct.bonds){
          const a = struct.atoms[b.a], c = struct.atoms[b.b];
          // optionally split multiple bonds (double/triple) — DB uses single bonds unless otherwise specified
          viewer.addCylinder({ start: a.pos, end: c.pos, radius: cylRadius, fromCap:true, toCap:true, color:'#cfcfcf' });
        }
      }

      viewer.zoomTo();
      viewer.render();
    }

    /**********************
     * UI logic
     **********************/
    document.getElementById('confirmBtn').addEventListener('click', () => {
      const raw = document.getElementById('molInput').value;
      const parsed = parseInput(raw);
      if(!parsed) { alert('Could not understand input. Try a formula (H2O) or supported name (ammonia, water, methane, benzene...).'); return; }
      const struct = buildFromData(parsed.key, parsed.data);
      renderStructure(struct);
    });

    document.getElementById('examplesBtn').addEventListener('click', () => {
      const ex = ['H2O','NH3','CH4','CO2','benzene','CH3OH','C2H6','C2H4','C2H2','H2','O2','N2'];
      const choice = prompt('Type example name or formula:\n' + ex.join(', '), 'NH3');
      if(choice) {
        document.getElementById('molInput').value = choice;
      }
    });

    // toggles re-render
    ['showLabels','showBonds','showNuclei','lowQuality'].forEach(id => {
      document.getElementById(id).addEventListener('change', () => {
        // re-render last displayed molecule if present, else render demo NH3
        const raw = document.getElementById('molInput').value;
        const parsed = parseInput(raw) || parseInput('NH3');
        const struct = buildFromData(parsed.key, parsed.data);
        renderStructure(struct);
      });
    });

    // initial demo: ammonia
    (function init(){
      const parsed = parseInput('NH3');
      const struct = buildFromData(parsed.key, parsed.data);
      renderStructure(struct);
      // make sure viewer fills container
      setTimeout(() => {
        viewer.setSize(document.getElementById('viewer').clientWidth, document.getElementById('viewer').clientHeight);
        viewer.render();
      }, 120);
    })();

    // responsive resizing
    window.addEventListener('resize', () => {
      viewer.setSize(document.getElementById('viewer').clientWidth, document.getElementById('viewer').clientHeight);
      viewer.render();
    });
  </script>
</body>
</html>
